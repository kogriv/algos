Longest Palindromic Substring
Medium
Topics
Companies
Hint
Given a string s, return the longest 
palindromic
 
substring
 in s.

 

Example 1:

Input: s = "babad"
Output: "bab"
Explanation: "aba" is also a valid answer.
Example 2:

Input: s = "cbbd"
Output: "bb"
----------

Для задачи Longest Palindromic Substring есть несколько 
классических подходов, помимо рекурсии. Вот основные из них:

1. Brute Force (перебор всех подстрок)
   - Перебираем все возможные подстроки.
   - Проверяем, является ли подстрока палиндромом.
   - Храним самую длинную найденную.
   - Сложность: O(N^3) (проверка на палиндром занимает O(N), а всего O(N^2) подстрок).

2. Расширение от центра (Expand Around Center)
   - Итерируем по строке, считая каждый символ (и пару символов) центром палиндрома.
   - Расширяем границы, пока подстрока остаётся палиндромом.
   - Сложность: O(N^2), но работает быстрее, чем brute force.

3. Динамическое программирование (Dynamic Programming)
   - Используем таблицу dp[i][j], где:
     - dp[i][j] = True, если подстрока s[i:j+1] – палиндром.
   - Заполняем dp от коротких подстрок к длинным.
   - Сложность: O(N^2), но позволяет легко восстановить саму подстроку.

4. Алгоритм Манакера (Manacher’s Algorithm)
   - Специальный алгоритм, работающий за O(N).
   - Строит вспомогательную строку с # между символами (#b#a#b#a#d#).
   - Использует радиус расширения палиндромов и зеркальность.
   - Самый быстрый способ, но сложен в реализации.

Какой метод выбрать?
- Базовое понимание → Brute Force (простой, но медленный).
- Оптимальный и понятный → Expand Around Center (эффективен и прост в коде).
- Для уверенности → DP (если хочется использовать матрицу).
- Самый быстрый → Manacher's Algorithm (но сложен в реализации).  

Рекурсия не очень удобна для этой задачи, так как приводит к повторным вычислениям и требует мемоизации, чтобы не получить экспоненциальную сложность.
